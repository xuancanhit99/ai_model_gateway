# app/api/routes/chat.py
from fastapi import APIRouter, HTTPException, status, Header, Depends
from supabase import Client # Thêm import Client
from app.models.schemas import ChatRequest, ChatResponse, ErrorResponse
from app.services.model_router import ModelRouter
from app.core.config import get_settings
from app.core.auth import verify_api_key_with_provider_keys # Sử dụng phiên bản nâng cao
from app.core.supabase_client import get_supabase_client # Thêm import get_supabase_client
from typing import Dict, Any

router = APIRouter()
settings = get_settings()

@router.post(
    "/generate-text",
    response_model=ChatResponse,
    summary="Generate Text Response using the specified model with failover",
    responses={
        status.HTTP_400_BAD_REQUEST: {"model": ErrorResponse},
        status.HTTP_500_INTERNAL_SERVER_ERROR: {"model": ErrorResponse},
        status.HTTP_503_SERVICE_UNAVAILABLE: {"model": ErrorResponse}, # Thêm 503 cho failover exhausted
    }
)
async def generate_chat_response(
    request_body: ChatRequest,
    x_google_api_key: str | None = Header(None, alias="X-Google-API-Key"),
    x_xai_api_key: str | None = Header(None, alias="X-xAI-API-Key"),
    x_gigachat_api_key: str | None = Header(None, alias="X-GigaChat-API-Key"),
    x_perplexity_api_key: str | None = Header(None, alias="X-Perplexity-API-Key"),
    auth_info: Dict[str, Any] = Depends(verify_api_key_with_provider_keys),
    supabase: Client = Depends(get_supabase_client) # Thêm dependency injection cho supabase
):
    """
    Receives a user message and optional chat history, then returns
    a text response generated by the specified model via ModelRouter,
    with API key failover support.
    """
    try:
        # Lấy provider keys từ DB (đã được giải mã)
        # ModelRouter sẽ tự xử lý việc lấy key được chọn và failover
        db_provider_keys = auth_info.get("provider_keys", {})

        # Chuẩn bị API keys dictionary ban đầu (ưu tiên header, sau đó DB)
        provider_api_keys: Dict[str, str] = {}
        google_key = x_google_api_key or db_provider_keys.get("google")
        grok_key = x_xai_api_key or db_provider_keys.get("xai") # Sử dụng 'xai'
        gigachat_key = x_gigachat_api_key or db_provider_keys.get("gigachat")
        perplexity_key = x_perplexity_api_key or db_provider_keys.get("perplexity")

        # Thêm key vào dictionary nếu có (khớp với key name trong ModelRouter)
        if google_key:
            provider_api_keys["google"] = google_key
        if grok_key:
            provider_api_keys["xai"] = grok_key # Sử dụng 'xai'
        if gigachat_key:
            provider_api_keys["gigachat"] = gigachat_key
        if perplexity_key:
            provider_api_keys["perplexity"] = perplexity_key

        # Use ModelRouter to route the request, passing supabase and auth_info
        response_text, model_used = await ModelRouter.route_simple_chat(
            model=request_body.model,
            message=request_body.message,
            history=request_body.history,
            provider_api_keys=provider_api_keys, # Truyền key ban đầu
            supabase=supabase, # Truyền supabase client
            auth_info=auth_info # Truyền thông tin xác thực
        )
        return ChatResponse(
            response_text=response_text,
            model_used=model_used
        )
    except HTTPException as http_exc:
        # Re-raise HTTPExceptions raised by the router/service (bao gồm 503)
        raise http_exc
    except Exception as e:
        # Catch any other unexpected errors during chat generation
        # Log the error e here
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An unexpected error occurred during chat generation: {e}"
        )